# Docker Architecture: Containers

**Docker-контейнер** — это запущенный экземпляр Docker-образа. Контейнеры предоставляют изолированную среду выполнения для приложений.

## Что такое Docker-контейнер?

### Ключевые характеристики

- **Isolated** (изолированный) - собственная файловая система, сеть, процессы
- **Ephemeral** (эфемерный) - временный, может быть легко пересоздан
- **Portable** (переносимый) - работает одинаково на любой системе с Docker
- **Lightweight** (легковесный) - разделяет ядро ОС с хост-системой

## Архитектура контейнера

### Структура "контейнер поверх образа"

```cli
┌─────────────────────────────────┐
│    Container Writable Layer     │ ← Read-write слой контейнера
├─────────────────────────────────┤
│    Docker Image (Read-only)     │ ← Базовые слои образа
│ ┌─────────────────────────────┐ │
│ │        App Layer            │ │
│ ├─────────────────────────────┤ │
│ │    Dependencies Layer       │ │
│ ├─────────────────────────────┤ │
│ │     Base OS Layer           │ │
│ └─────────────────────────────┘ │
└─────────────────────────────────┘
```

### Компоненты контейнера

- **Image Layers** (слои образа) - неизменяемая основа (read-only)
- **Container Layer** (слой контейнера) - записываемый слой для изменений
- **Namespace** (пространство имён) - изоляция процессов, сети, файловой системы
- **Cgroups** (control groups) - ограничения ресурсов (CPU, memory, I/O)

## Жизненный цикл контейнера

### Состояния контейнера

```cli
created → running → paused → stopped → deleted
    ↑         ↓         ↑         ↑
    └─────────┴─────────┴─────────┘
       возможные переходы
```

### States (состояния)

- **Created** (создан) - контейнер создан, но не запущен
- **Running** (запущен) - контейнер выполняется
- **Paused** (приостановлен) - процессы заморожены
- **Stopped** (остановлен) - процессы завершены
- **Exited** (завершён) - выполнение завершено
- **Dead** (мёртв) - контейнер не может быть запущен

## Изоляция контейнеров

### Linux Namespaces

- **PID namespace** - изоляция дерева процессов
- **Network namespace** - изоляция сетевого стека
- **Mount namespace** - изоляция файловой системы
- **UTS namespace** - изоляция hostname и domainname
- **IPC namespace** - изоляция межпроцессного взаимодействия
- **User namespace** - изоляция UID/GID

### Control Groups (cgroups)

- **CPU limits** (ограничения CPU) - доля процессорного времени
- **Memory limits** (ограничения памяти) - максимальное использование RAM
- **I/O throttling** (ограничение ввода-вывода) - лимиты дисковых операций
- **Device access** (доступ к устройствам) - контроль доступа к устройствам

## Файловая система контейнера

### Copy-on-Write в действии

```cli
Контейнер запускается: [Image Layers] + [Empty Writable Layer]
↓
Чтение файла: обращение к Image Layers
↓
Изменение файла: копирование в Writable Layer + модификация
↓
Последующие чтения: Writable Layer (при наличии) → Image Layers
```

### Типы хранения данных

- **Writable Layer** (записываемый слой) - временные изменения (исчезают при удалении контейнера)
- **Volumes** (тома) - постоянное хранение данных
- **Bind Mounts** (bind-монтирования) - связь с хост-файловой системой
- **tmpfs mounts** (tmpfs-монтирования) - хранение в памяти

## Сетевые возможности

### Network Drivers (драйверы сети)

- **bridge** (мост) - стандартная изолированная сеть
- **host** (хост) - использование сетевого стека хоста
- **none** (отсутствие) - полная сетевая изоляция
- **overlay** (оверлей) - сеть между несколькими Docker-хостами
- **macvlan** - прямое назначение MAC-адресов

### Порт forward (проброс портов)

```cli
Контейнер:80 → Хост:8080
Внешний трафик на host:8080 перенаправляется в container:80
```

## Взаимодействие с хост-системой

### Resource Management (управление ресурсами)

- **CPU shares** (доли CPU) - относительное распределение процессорного времени
- **Memory limits** (лимиты памяти) - жесткие и мягкие ограничения RAM
- **Storage drivers** (драйверы хранения) - управление слоями и контейнерными данными

### Security Context (безопасность)

- **User namespace** - отображение UID/GID между контейнером и хостом
- **SELinux/AppArmor** - мандатный контроль доступа
- **Capabilities** (возможности) - ограничение привилегий процессов

## Модель выполнения

### Process Isolation (изоляция процессов)

- Процесс №1 в контейнере = Процесс №1000 на хосте
- **PID 1** в контейнере отвечает за сигналы и zombie-процессы
- Рекомендуется использовать **init systems** для PID 1

### Signal Handling (обработка сигналов)

- `docker stop` → `SIGTERM` → `SIGKILL` (после таймаута)
- `docker kill` → немедленный `SIGKILL`
- Приложения должны корректно обрабатывать `SIGTERM` для graceful shutdown

## Оркестрация и масштабирование

### Container Runtimes (среды выполнения)

- **containerd** - стандартная низкоуровневая среда выполнения
- **runc** - reference implementation OCI runtime

### Scaling Patterns (шаблоны масштабирования)

- **Stateless** (без состояния) - горизонтальное масштабирование
- **Stateful** (с состоянием) - требует управления состоянием
- **Worker patterns** (воркеры) - обработка задач из очереди

## Отличия от виртуальных машин

### Контейнеры vs VM

```cli
Контейнеры: [App A] [App B] [App C]
            │       │       │
            └─── Docker Engine ───┘
            │       Kernel        │
            └─── Hardware ───────┘

Виртуальные машины: [App A] [App B] [App C]
                    │       │       │
                    └─ Guest OS ───┘
                    │  Hypervisor  │
                    └─ Hardware ───┘
```

**Архитектурный принцип**: Docker-контейнеры обеспечивают легковесную, изолированную среду выполнения, построенную на механизмах ядра Linux, что позволяет достичь высокой плотности размещения и быстрого запуска приложений по сравнению с традиционной виртуализацией.
